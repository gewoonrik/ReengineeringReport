\documentclass{article}
\usepackage[a4paper]{geometry}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{rotating}
\usepackage{amsmath}
\usepackage{hyperref}
\usepackage{pdflscape}
\usepackage{listings}
\usepackage{color}
\usepackage{float}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\lstset{language=Java}

\author{Martijn Dwars (4156730) \and Rik Nijessen (4152263)}

\title{Assignment 1 \\ Software Reengineering (IN4189)}

\begin{document}

\maketitle

\section{Initial Understanding}
% What are the main features of the program?
% todo: misschien iets over Platform/Ecosystemen/Plugins
Alitheia Core is an advanced software repository analysis system \cite{sqooss-docs}. More specifically, it is an extensible platform for software quality analysis that is designed to facilitate software engineering research on large and diverse data sources. It provides implementations for low level tasks and allows researchers to focus on quantitative and exploratory studies by writing plugins on a more abstract level \cite{sqooss-about}.

To get an initial understanding of the system, we looked at available documentation, available tests, and the architecture.

\begin{enumerate}
\item \textbf{Documentation} The website contains some documentation explaining the architecture, which was really helpful~\cite{sqooss-reference}. The code contains some JavaDoc, although we would have liked to see some more documentation.

\item \textbf{Tests} There are very little tests. At first sight this indicates bad quality. We observed that some tests sporadiccally fail, which indicates bad quality.

\item \textbf{Architecture} The project contains a clear structure. There is \verb|service| package which contains all services. The \verb|impl.service| package contains implementations for these services. The god class \verb|AlitheiaCore| contains a binding of interfaces to their corresponding implementation.
\end{enumerate}

Based on our initial understanding, we think reengineering is feasible. The project contains a decent structure, which makes it a good candidate for reengineering. The lack of tests is unfortunately but can be overcome by putting more effort in analzying the code. Furthermore, it would take more time and resources to build the system from scratch than to reengineer the current system.

The lack of tests also makes refactoring hard. This is because it is not possible to check if the code is still functioning correctly after doing refactoring. Therefore tests should be written before making an attempt to refactor the code.

\section{Detailed Model Capture}
Based on the package map's and inheritance map's generated by inFusion Hydrogen v1.8.5\footnote{http://www.intooitus.com/products/infusion}, we observe several interesting facts.

From the package map's coupling perspective we observe that \verb|AlitheiaCore| acts as a provider to a lot of other classes. Figure~\ref{fig:alitheiacore} shows the clients of \verb|AlitheiaCore| in yellow. Further investigation shows that \verb|AlitheiaCore| is used as an access point to all services.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{alitheiacore-coupling}
    \caption{AlitheiaCore (green), its clients (yellow)}
    \label{fig:alitheiacore}
\end{figure}

From the inheritance map we observe that \verb|DAObject| (figure~\ref{fig:daobject}) and \verb|AlitheiaCoreService| (figure~\ref{fig:alitheiacoreservice}) have a lot of subclasses. The subclasses of \verb|AlitheiaCoreService| are interfaces for each service.

\begin{figure}[h]
\centering
\begin{minipage}{.45\textwidth}
  \centering
  \includegraphics[width=0.9\linewidth]{daoobject-inheritance}
  \captionof{figure}{DAObject (green) and subclasses (bordered)}
  \label{fig:daobject}
\end{minipage}\hspace{5mm}%
\begin{minipage}{.45\textwidth}
  \centering
  \includegraphics[width=0.9\linewidth]{alitheiacoreservice-inheritance}
  \captionof{figure}{AlitheiaCoreService (green) and subclasses (bordered)}
  \label{fig:alitheiacoreservice}
\end{minipage}
\end{figure}

A lot can be learned from the inheritance tree. We used IntelliJ IDEA 14~\footnote{https://www.jetbrains.com/idea/} to generate an inheritance diagram. Appendix~\ref{app:inheritance} contains the most important parts of the inheritance tree. From this tree, it is even more obvious that every service has an interface that extends \verb|AlitheiaCoreService|. For each of these interface an implementation exists in the package \verb|eu.sqooss.impl.service|. % zeg iets over DAObject

\section{Problem Detection}
In this section we will explain some S.O.L.I.D. and other violations we have found in the Alitheia Core source code. We will among others discuss the following principles:
\begin{itemize}
  \item Single Responsibility (SRP)
  \item Open/closed (OCP)
  \item Liskov substitution (LSP)
  \item Dependency Inversion (DIP)
  \item Acyclic Dependencies (ADP)
  \item Dont Repeat Yourself (DRY)
\end{itemize} 
\subsection{SRP violation}
\label{sec:srp}
The SRP is violated in many places. We list three of them below.

\begin{enumerate}
\item The abstract class \verb|Job| contains a lot of methods. Its main responsibility is to represent the concept of a \emph{job}. To accomplish this it contains properties (e.g. state, dependencies, dependees) and methods (addDependency, removeDependency, dependsOn) to alter its state.

However, the class also exposes a method called \verb|execute()|. This indicates that the \verb|Job| class is also responsible for executing a job. This is a violation of the SRP, because there is more than one motive for chaning the \verb|Job| class: either if the way we represent a job changes, or if the way we execute a job changes. A better architecture would be to move the job execution out of the \verb|Job| class and into a service layer (for example, \verb|JobExecuter|).

\item The class \verb|ProjectsView.java|: its name suggests that it renders HTML output, but it also takes care of parsing the servlet's request object, adding projects, removing projects, and triggering updates.

\item The class \verb|Bug| should represent a bug. It should not be aware of the way in which it is persisted. Moreover, it should not be awere that it is persisted at all. The current implementation of \verb|Bug| contains SQL queries for retrieving information from the database and code for constructing the \verb|Bug| object. This violates the SRP principle.

% \item The ProjectEvent interface delcares a getEventPriority method and RepositoryEvent, MailingListEvent, and BugDBEvent implement this method. However, each class returns a constant. This indicates that event priority is actually not a property of these events. Diving a bit deeper we see that this method is used to compare ProjectEvent's. A correct way to implement this would be to create a custom comparator, which inspects the runtime type to compare two ProjectEvents. This is more extensible then returning integers (imaging creating an event that has property between two existing properties) and more maintainable.
\end{enumerate}

\subsection{OCP violation}
The \verb|Metric| class contains a property \verb|metricType: MetricType|. The \verb|MetricType| contains a \verb|Type| enumeration of types and a property \verb|type: String|. The \verb|Metric| class also contains a method \verb|isEvaluated|. Depending on \verb|metricType.getEnumType()| this method constructs a different query. Listing~\ref{lst:ocp} shows a simplified version of this code.

\begin{lstlisting}[caption=OCP violation,label={lst:ocp}]
public class Metric extends DAObject {
	private MetricType metricType;
	// ...
	public boolean isEvaluated(StoredProject p) {
		switch (metricType.getEnumType()) {
			case PROJECT_VERSION:
				// Build query
			case SOURCE_FILE:
				// Build query
			// ... etc
		}
	}
}
\end{lstlisting}

This paradigm is not open for modification, because we need to change the \verb|Metric| class every time we add a new type of metric. To solve this issue, we suggest adding a \verb|buildQuery(): String| method to a \verb|MetricType| interface from which all \verb|MetricType|'s must inherit. The \verb|isEvaluated| method can then be made to depend on the \verb|MetricType| interface and call \verb|buildQuery| on a concrete \verb|MetricType| to construct a query for that specific metric type.

We found this issue by searching for usages of `switch' in IntelliJ.

\subsection{LSP violation}
The class \verb|ProjectDirectory| inherits from \verb|ProjectFile|. However, not all properties that hold for \verb|ProjectFile| also hold for \verb|ProjectDirectory|. For example, whereas \verb|getFileName| would make sense for a \verb|ProjectFile|, it does not for a \verb|ProjectDirectory|.

We found this issue by inspecting the inheritance tree (see Appenidix~\ref{app:inheritance}). The fact that the subtyping does not establish an ``is-a'' relationship (i.e. a semantic relationship) indicates a possible violation of the LSP.

\subsection{DIP violation}
The DIP states that high level modules should not depend upon low level modules. Both should depend upon abstractions. In AlitheiaCore, several modules depend upon implementations instead of abstractions. One such example is the \verb|InMemoryCheckout| class, which depends upon the low level \verb|InMemoryDirectory|.

The DIP is also violated in a different way. The class \verb|CacheServiceImpl| knows about its subclass and even instantiates it. Listing~\ref{lst:dip} illustrates this code. Being aware of your subclasses clearly violates the DIP. The class should depend on abstractions instead of implementations.

\begin{lstlisting}[caption=DIP violation,label={lst:dip}]
public class CacheServiceImpl implements CacheService {
	private CacheService c;
	// ...
	public boolean startUp() {
		String impl = System.getProperty(CACHE_IMPL);
        
        if (impl == null)
            impl = "eu.sqooss.service.cache.OnDiskCache";

        try {
            Class clazz = Thread.currentThread().getContextClassLoader().loadClass(impl);
            c = (CacheService) clazz.newInstance();
        }
        // ...
	}
}
\end{lstlisting}

\subsection{ADP violation}
We have searched for cyclic dependencies between packages using the `Analyze Cyclic Dependencies' feature in IntelliJ IDEA 14. A lot of interfaces in the package \verb|eu.sqooss.service| extend \verb|AlitheiaCoreService| in the package \verb|eu.sqooss.core|. These interfaces are also referenced in the \verb|AlitheiaCore| class. This means that the package \verb|eu.sqooss.service| depends on the package \verb|eu.sqooss.core| (via the \verb|AlitheiaCoreService| interface), but the \verb|eu.sqooss.core| package also depends on the \verb|eu.sqooss.service| package (via the \verb|AlitheiaCore| class), so this is an ADP violation. Figure~\ref{fig:adp} illustrates these dependencies.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{ADP-example}
    \caption{ADP violation}
    \label{fig:adp}
\end{figure}

Furthermore, a lot of classes in the package \verb|eu.squooss.impl.service| implement interfaces from the \verb|eu.sqooss.service| package. These are then bounded to these interfaces in the \verb|AlitheiaCore| class, so this is also an ADP violation.

Violating the ADP principle results in circulair dependencies between packages. This can cause a lot of indirect dependencies, which makes the system much harder to maintain~\cite{stan4j}.

\subsection{DRY violation}
In the class \verb|ProjectVersion| a lot of duplicate is shared between the \verb|getLiveFilesCount| and \verb|getVersionFiles| methods. 

Furthermore, in the same class the methods \verb|getVersionByRevision| and \verb|getVersionByTimestamp| are exactly the same aside from one parameter.
Duplicate code is harder to maintain, because code has to be changed at multiple places. This can be a source of errors too, because it is easy to forget to change copies of code. 

% per principle:
% - wat het inhoud
% - hoe we gezocht hebben
% - wat we gevonden hebben

\subsection{Code smells}
We identified several code smells. Code smells are considered less important than SOLID violations. However, in order to maintain a high quality code base, we advice to address these smells and take appropriate measures.

\begin{enumerate}
\item The system uses \verb|AlitheiaCore| for providing implementations for certain interfaces, which is better than relying on implementations. However, this can be taken one step further by applying Inversion of Control (IoC)~\cite{ioc}. Instead creating your dependencies, you declare your dependencies and let someone higher up take care of creating them. This increases decoupling and makes maintaining code easier.

\item The code base contains commented code. See for example the \verb|createTestFiles| method in \verb|DiskUtil.java|, the \verb|static final int|'s you find above and below in that file. Also, \verb|Parser.java| is not used. We advice using a proper Version Control System (VCS) and only integrate production-code in the main branch.

\item Comments containing `TODO' or `FIXME'. Though this is not necessarily harmful, it is considered a better practice to store these in an issue tracker. An issue tracker provides others with an easy to grasp overview of existing issues. Furthermore, an issue tracker allows for more meaningful description's than ``this can break''.
\end{enumerate}

\bibliographystyle{plain}
\bibliography{report}

\newpage
\appendix
\section{Inheritance tree} \label{app:inheritance}

\begin{sideways}
	\includegraphics[width=1.3\textwidth]{inheritance-diagram}
	\label{fig:inheritance}
\end{sideways}

\end{document}